---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xingweihao.
--- DateTime: 2018/10/12 3:27 PM
---
---@class PopMainVegeTableNode
local PopMainVegeTableNode = class('PopMainVegeTableNode', function ()
	local node = display.newLayer(0,0,{ap = display.CENTER , size = cc.size(302.3,174.9)})
	--CLayout:create(cc.size(302.3,174.9))
	node.name = 'Game.views.link.PopMainVegeTableNode'
	node:setName('PopMainVegeTableNode')
	node:enableNodeEvents()
	return node
end)

local RES_DICT={
	POP_FARM_GUIDE_LINE_RIGHT                = _res("ui/link/popMain/pop_farm_guide_line_right.png"),
	COMMON_BG_TIPS                           = _res("ui/link/popMain/common_bg_tips.png"),
	POP_FARM_LAND_BG                         = _res("ui/link/popMain/pop_farm_land_bg.png"),
	COMMON_ICO_LOCK                          = _res('ui/common/common_ico_lock.png'),
	POP_FARM_GUIDE_LINE_LEFT                 = _res("ui/link/popMain/pop_farm_guide_line_left.png"),
	POP_ICON_SEEDS                           = _spn("ui/link/popMain/animation/pop_icon_seeds") ,
	POP_FARM_ICON_REAPED                     = _spn("ui/link/popMain/animation/pop_farm_icon_reaped") ,
	POP_FARM_ICON_QUICKEN                    = _spn("ui/link/popMain/animation/pop_farm_icon_quicken") ,
	POP_FARM_GUIDE_3                         = _spn("ui/link/popMain/animation/pop_farm_guide_3"),
}
local VEGETABLE_STATUS = {
	FREE        = 1,
	SEED_STATUS = 2,
	GROW_UP     = 3,
	MATURE      = 4
}
function PopMainVegeTableNode:ctor( ... )
	self.countDownEvent = nil
	self.status  = 0
	local cellSize = cc.size(302.3,174.9)
	local land_bg = display.newImageView(RES_DICT.POP_FARM_LAND_BG , cellSize.width/2 , cellSize.height/2)
	self:addChild(land_bg)
	land_bg:setVisible(false)
	local icoLockImage = display.newImageView(RES_DICT.COMMON_ICO_LOCK , cellSize.width/2+10 , cellSize.height/2+10)
	self:addChild(icoLockImage)
	icoLockImage:setVisible(false)

	local guideSpine3 = sp.SkeletonAnimation:create(RES_DICT.POP_FARM_GUIDE_3.json , RES_DICT.POP_FARM_GUIDE_3.atlas)
	guideSpine3:setAnimation(0, "idle" , true)
	guideSpine3:setPosition(cellSize.width/2+10 , cellSize.height/2+10)
	guideSpine3:setVisible(false)
	self:addChild(guideSpine3)

	local seedSpine = sp.SkeletonAnimation:create(RES_DICT.POP_ICON_SEEDS.json , RES_DICT.POP_ICON_SEEDS.atlas)
	seedSpine:setAnimation(0, "idle1" , true)
	self:addChild(seedSpine)
	seedSpine:setPosition(cellSize.width/2 , cellSize.height/2)
	seedSpine:registerSpineEventHandler(handler(self , self.SpineCallBack), sp.EventType.ANIMATION_COMPLETE)
	seedSpine:setVisible(false)
	local oneTimeLayout = display.newLayer(104.15, 110,{color = cc.c4b(0,0,0,0), enable= false, ap = display.LEFT_CENTER,size = cc.size(300,40)})
	self:addChild(oneTimeLayout)
	oneTimeLayout:setVisible(false)
	local guideRight = display.newImageView( RES_DICT.POP_FARM_GUIDE_LINE_RIGHT ,79, 17,{ap = display.CENTER})
	oneTimeLayout:addChild(guideRight,0)
	local timeBgImage = display.newImageView( RES_DICT.COMMON_BG_TIPS ,162, 17,{ap = display.CENTER,scaleX = 0.7,scaleY = 0.85})
	oneTimeLayout:addChild(timeBgImage,0)
	local timeLabel = display.newLabel(162, 15 , {fontSize = 28,text = '',color = '#78564b',ap = display.CENTER})
	oneTimeLayout:addChild(timeLabel,0)
	oneTimeLayout.viewData = {
		layout = oneTimeLayout ,
		guideImage = guideRight ,
		timeLabel = timeLabel
	}
	local twoTimeLayout = display.newLayer(200, 110 ,{color = cc.c4b(0,0,0,0),enable= false,ap = display.RIGHT_CENTER,size = cc.size(300,40)})
	self:addChild(twoTimeLayout,0)
	twoTimeLayout:setVisible(false)
	local guideLeft = display.newImageView( RES_DICT.POP_FARM_GUIDE_LINE_LEFT ,208.3, 17,{ap = display.CENTER})
	twoTimeLayout:addChild(guideLeft,0)
	local timeBgImage = display.newImageView( RES_DICT.COMMON_BG_TIPS ,140, 17.7,{ap = display.CENTER,scaleX = 0.7,scaleY = 0.85})
	twoTimeLayout:addChild(timeBgImage,0)
	local timeLabel = display.newLabel(125, 17 , {fontSize = 28,text = '',color = '#78564b',ap = display.CENTER})
	twoTimeLayout:addChild(timeLabel,0)


	twoTimeLayout.viewData = {
		layout = twoTimeLayout ,
		guideImage = guideLeft ,
		timeLabel = timeLabel
	}
	self.viewData = {
		land_bg = land_bg ,
		icoLockImage  = icoLockImage,
		guideSpine3   = guideSpine3 , 
		oneTimeLayout = oneTimeLayout,
		twoTimeLayout = twoTimeLayout,
		seedSpine     = seedSpine ,
		timeLabel = nil
	}
end
function PopMainVegeTableNode:CreateReapedSpine()
	if not self.viewData.reapedSpine then
		local reapedSpine = sp.SkeletonAnimation:create(RES_DICT.POP_FARM_ICON_REAPED.json , RES_DICT.POP_FARM_ICON_REAPED.atlas)
		reapedSpine:setAnimation(0, "idle" , true)
		reapedSpine:setPosition(302.3/2,174.9/2)
		self:addChild(reapedSpine, 10)
		self.viewData.reapedSpine = reapedSpine
	end
	--reapedSpine:setVisible(false)
	--reapedSpine:setName("reapedSpine")
end
function PopMainVegeTableNode:CreateQuickSpine(parentNode,typeNum)
	local quickSpine = sp.SkeletonAnimation:create(RES_DICT.POP_FARM_ICON_QUICKEN.json , RES_DICT.POP_FARM_ICON_QUICKEN.atlas)
	quickSpine:setAnimation(0, "idle" , true)
	if typeNum == 1 then
		quickSpine:setPosition(90 , 20)
	else
		quickSpine:setPosition(200 , 20)
	end

	parentNode:addChild(quickSpine, 10)
	--quickSpine:setVisible(false)
	quickSpine:setName("quickSpine")
end

function PopMainVegeTableNode:UpdateLand(landData)
	local unlock = landData.unlock 
	local landId = checkint(landData.landId)
	self:setTag(landId)
	self.viewData.land_bg:setVisible(false)
	self.viewData.icoLockImage:setVisible(false)
	self.viewData.oneTimeLayout:setVisible(false)
	self.viewData.twoTimeLayout:setVisible(false)
	self.viewData.seedSpine:setVisible(false)
	self.countDownEvent = string.format("POP_VEGETABLE_NODE_EVENT_%d" , landId)
	self.spineShowEvent = string.format("POP_VEGETABLE_NODE_UNLOCK_SPINE_SHOW_EVENT_%d" , landId)
	self:RegistObserver()
	local reapedSpine = self.viewData.reapedSpine
	if reapedSpine and (not tolua.isnull(reapedSpine)) then
		self.viewData.reapedSpine = nil
		reapedSpine:runAction(cc.RemoveSelf:create())
	end
	if checkint(landData.status) > 0 then
		self.status = checkint(landData.status)
	end
	--self.viewData.seedImage:setVisible(false)
	if unlock then
		if landData.seed and checkint(landData.seed.seedId) > 0  then
			self.viewData.seedSpine:setVisible(true)
			if landId == 1 or landId == 2 or landId == 4 then
				self.viewData.timeLabel = self.viewData.oneTimeLayout.viewData.timeLabel
				self.viewData.oneTimeLayout:setVisible(true)
				self.viewData.twoTimeLayout:setVisible(false)
				local quickSpine = self.viewData.oneTimeLayout:getChildByName("quickSpine")
				if  not quickSpine then
					self:CreateQuickSpine(self.viewData.oneTimeLayout,1)
				end
			else
				self.viewData.timeLabel = self.viewData.twoTimeLayout.viewData.timeLabel
				self.viewData.oneTimeLayout:setVisible(false)
				self.viewData.twoTimeLayout:setVisible(true)
				local quickSpine = self.viewData.twoTimeLayout:getChildByName("quickSpine")
				if  not quickSpine then
					self:CreateQuickSpine(self.viewData.twoTimeLayout,2)
				end
			end

			local matureLeftSeconds = checkint(landData.seed.matureLeftSeconds)
			local status = 0  
			if matureLeftSeconds == 0  then
				status = VEGETABLE_STATUS.MATURE
			else
				status = VEGETABLE_STATUS.SEED_STATUS
			end
			self.status = status
			if self.status == VEGETABLE_STATUS.SEED_STATUS then
				self.viewData.seedSpine:setAnimation(0, "idle2" , false)
			elseif self.status == VEGETABLE_STATUS.MATURE then
				if self.status == VEGETABLE_STATUS.MATURE then
					self:UpdateCompleteStatus()
				end
				self.viewData.seedSpine:setAnimation(0, "idle3" , false)
			end
		end
	else
		self.viewData.land_bg:setVisible(true)
		self.viewData.icoLockImage:setVisible(true)
	end
end

function PopMainVegeTableNode:SpineCallBack(event)
	if event.animation == "play1" then
		self.viewData.seedSpine:setAnimation(0,"idle2" , true)
	elseif event.animation == "play2" then
		if self.status == VEGETABLE_STATUS.MATURE then
			self:UpdateCompleteStatus()

		end
		self.viewData.seedSpine:setAnimation(0,"idle3" , true)
	end
end

function PopMainVegeTableNode:UpdateSpineStatus(landData)
	local seed = landData.seed
	local matureLeftSeconds = checkint(seed.matureLeftSeconds)
	local status = 0
	if matureLeftSeconds == 0  then
		status = VEGETABLE_STATUS.MATURE
	else
		status = VEGETABLE_STATUS.SEED_STATUS
	end
	if self.status == status then
		return
	end
	if status == VEGETABLE_STATUS.SEED_STATUS then
		self.viewData.seedSpine:setToSetupPose()
		self.viewData.seedSpine:setAnimation(0,"play1", false)
	elseif status == VEGETABLE_STATUS.MATURE then
		self.viewData.seedSpine:setToSetupPose()
		self.viewData.seedSpine:setAnimation(0,"play2", false)

	end
	self.status = status
end

function PopMainVegeTableNode:UpdateCompleteStatus()
	local reapedSpine = self.viewData.reapedSpine
	if not  reapedSpine then
		self:CreateReapedSpine()
	end
	self.viewData.oneTimeLayout:setVisible(false)
	self.viewData.twoTimeLayout:setVisible(false)
end

function PopMainVegeTableNode:CheckVegeTableNode(worldPos)
	local parentNode = self:getParent()
	local parentNodePos =parentNode:convertToNodeSpace(worldPos)
	local isIn = self:InRectangleContent(parentNodePos)
	local nodePos = self:convertToNodeSpace(worldPos)
	-- 如果在矩形内部 走接下来的判断
	local vegeTablePos = require("Game.views.link.popMain.PopVegetablePos")
	local landId = self:getTag()
	local nodes =  vegeTablePos[checkint(landId)].nodes
	if isIn then
		isIn = self:JuageInPolygonPoint(nodePos ,nodes )
		if not isIn then
			isIn = self:JuageInPolygonLine(nodePos ,nodes )
			if not isIn then
				isIn = self:RadialIntersectant(nodePos,nodes)
			end
		end
	end
	if isIn then
		app:DispatchObservers("POP_VEGETABLE_CELL_CLICK_EVENT" , {landId = self:getTag()})
	end
end
--==============================--
--desc:判断是否在矩形的内部
--time:2017-07-28 08:37:33
--@return
--==============================--
function PopMainVegeTableNode:InRectangleContent(pos)
	local isIn = false
	local rect = self:getBoundingBox()
	isIn = cc.rectContainsPoint(rect,pos)
	return isIn
end

-- 证明改图新是在多边形的点上

function PopMainVegeTableNode:JuageInPolygonPoint(pos , posTable)
	local isIn = false
	for k , v in pairs (posTable) do
		if pos.x == v.x and pos.y == v.y then -- 证明改图新是在多边形的点上
			isIn = true
			break
		end
	end
	return isIn
end
--==============================--
--desc:判断是否在多边形的边上
--time:2017-07-31 02:52:56
--@pos:传入点击的点
--@posTable:传入的多边形的点
--@return
--==============================--
function PopMainVegeTableNode:JuageInPolygonLine(pos ,posTable )
	local isIn = false
	local count = #posTable
	for i =1 , count do
		local addI = i +1
		if  addI > count then  --这个表示链接线段的点点
			addI = addI - count
		end
		-- 计算一条线的斜率
		local isParallel = false
		if (pos.x - posTable[i].x) == 0 and (posTable[addI].x - posTable[i].x) == 0  then  -- 计算线的斜率是否在竖直方向上
			isParallel = true
		elseif  (pos.x - posTable[i].x) ~= 0 and (posTable[addI].x - posTable[i].x) ~= 0 then
			local vecOneNum = (pos.y - posTable[i].y) /(pos.x - posTable[i].x)
			-- 计算第二条线的斜率
			local vecTwoNum =  (posTable[addI].y - posTable[i].y) /(posTable[addI].x - posTable[i].x)
			if vecTwoNum == vecOneNum then
				isParallel = true
			end
		end

		if isParallel then  -- 如果两条线段的斜率相等 则证明是在一条线上
			local firstSegment = math.sqrt( math.pow(pos.y - posTable[i].y ,2)  +  math.pow(pos.x - posTable[i].x ,2)  )
			local secondSegment = math.sqrt( math.pow(pos.y - posTable[addI].y ,2)  +  math.pow(pos.x - posTable[addI].x ,2)  )
			local thirdSegment = math.sqrt( math.pow(posTable[addI].y - posTable[i].y ,2)  +  math.pow(posTable[addI].x - posTable[i].x ,2)  )

			if thirdSegment > secondSegment  and thirdSegment > firstSegment then  -- 如果第三条边最长 ，证明点击的点是在该线段上
				isIn = true
				break
			end
		end
		-- 取得点与其他两点相连
	end
	return isIn
end
--==============================--
--desc:利用半线理论检测该点是否在多边形的内部
--计算点在多边形内外的算法
-- 1． 理论基础  半线理论 说明：  判断一个点是否在多边形内，只要从这个点向多边形外做一条射线（随机取极远处的一个点，以这两点为端点做一条线段即可），
--  那么统计射线和多边形的边的交点个数，如果交点个数是奇数表明点在多边形内，否则在多边形外 ，如果共享点的两边在射线的同一侧 若交点的在射线下面计数器加二 若交点在计数器上面计数器为零 记 上无下有
--time:2017-07-28 05:09:30
--@return
--==============================--
function PopMainVegeTableNode:RadialIntersectant(pos,posTable)
	-- 以本点向右做一个射线
	local count = #posTable
	local i = 1
	local intersectantNum = 0 -- 交点坐标的记录
	while(i <= count) do
		local addI = i +1
		if addI > count then
			addI = addI - count
		end

		local maxY =(posTable[i].y >  posTable[addI].y and posTable[i].y)  or posTable[addI].y
		local minY = (posTable[i].y <  posTable[addI].y and posTable[i].y)  or posTable[addI].y
		local maxX = (posTable[i].x >  posTable[addI].x and posTable[i].x ) or posTable[addI].x
		if pos.x <= maxX and pos.y >= minY and pos.y <=maxY then --  证明射线和线段相交

			if minY ~= maxY then
				if pos.y > minY  and  pos.y < maxY then  --相交点记录
					if posTable[i].x -  posTable[addI].x  ~= 0  then  --不在竖直方向上
						local k = (posTable[i].y -  posTable[addI].y ) /   (posTable[i].x -  posTable[addI].x)
						local b  =  posTable[i].y  - k * posTable[i].x
						local _x = (pos.y  - b) / k
						if  _x >= pos.x then
							intersectantNum  = intersectantNum +1
						end
					else
						if  posTable[i].x > pos.x then
							intersectantNum  = intersectantNum +1
						end
					end

				elseif pos.y == maxY  then   -- 线段在射线下面
					intersectantNum = intersectantNum +1
				end
			end
		end
		i = i + 1
	end
	if  intersectantNum % 2 == 0 then
		return false
	else
		return true
	end
end
function PopMainVegeTableNode:UpdateTimeLabel(signal)
	local landData = signal:GetBody()
	local seed = landData.seed
	local matureLeftSeconds = checkint(seed.matureLeftSeconds)
	if not self.viewData.timeLabel then
		local landId = self:getTag()
		if landId == 1 or landId == 2 or landId == 4 then
			self.viewData.timeLabel = self.viewData.oneTimeLayout.viewData.timeLabel
		else
			self.viewData.timeLabel = self.viewData.twoTimeLayout.viewData.timeLabel
		end
	end
	self.viewData.timeLabel:setString(CommonUtils.getTimeFormatByType(matureLeftSeconds , 0 ))
	self:UpdateSpineStatus(landData)
end

function PopMainVegeTableNode:UpdateVegeNodeLockSpineIsShow(signal)
	local landData = signal:GetBody()
	local canUnLock = landData.canUnLock
	local landId = checkint(landData.landId)
	local tag = self:getTag()
	if landId == tag then
		if  canUnLock then
			self.viewData.guideSpine3:setVisible(true)
		else
			self.viewData.guideSpine3:setVisible(false)
		end
	end

end

function PopMainVegeTableNode:RegistObserver()
	if not (self.countDownEvent and string.len(self.countDownEvent)) then
		return
	end
	app:RegistObserver(self.countDownEvent , mvc.Observer.new(self.UpdateTimeLabel , self))
	app:RegistObserver(self.spineShowEvent , mvc.Observer.new(self.UpdateVegeNodeLockSpineIsShow , self))
end

function PopMainVegeTableNode:UnRegistObserver()
	app:UnRegistObserver(self.countDownEvent , self)
	app:UnRegistObserver(self.spineShowEvent , self)
	self.countDownEvent = nil
end

function PopMainVegeTableNode:onCleanup()
	self:UnRegistObserver()
end
return PopMainVegeTableNode
